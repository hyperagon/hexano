<!--
the hexnboard should touch the right size, right now the totalwidth is too big. make sure that the totalwidth and totalheight take into account the spacing.

rotate the hexboard if the width is smaller than the height

make sure that this uses HTML4 and CSS3
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexagon Piano</title>
    <style type="text/css">
        /* --- Basic Setup & Theme --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: Arial, sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        /* --- Main Layout --- */
        .app-container {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .hexboard {
            position: absolute;
            top: 54px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        /* --- Control Bar --- */
        .control-bar {
            display: block;
            position: relative;
            padding: 10px 20px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #000;
            z-index: 10;
            text-align: center;
        }

        .control-bar-label {
            font-size: 0.8em;
            margin-right: -12px;
            color: #aaa;
            display: inline-block;
        }
        
        .control-bar button, .control-bar select {
            background: none;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 16px;
            margin: 0 5px;
            vertical-align: middle;
        }

        .control-bar select {
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
        }

        .control-bar input[type="range"] {
            width: 100px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        #record-button {
            width: 32px;
            height: 32px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            transition: border-color 0.2s, box-shadow 0.3s;
        }

        #record-button.recording {
            border-color: #ff4136;
            animation: pulse 1.5s infinite;
        }

        #record-indicator {
            width: 18px;
            height: 18px;
            background-color: #ff4136;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -9px;
            margin-left: -9px;
            transform: scale(0);
            transition: transform 0.2s ease-in-out;
        }

        #record-button.recording #record-indicator {
            transform: scale(1);
        }

        #play-button, #fullscreen-button {
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-block;
            vertical-align: middle;
        }

        .icon {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        /* --- SVG Piano Styling --- */
        .piano-svg {
            display: block;
            transform: rotate(0deg);
        }
        
        .hexagon {
            cursor: pointer;
            stroke: black;
            stroke-width: 1px;
            transition: fill 0.05s ease-in-out;
        }

        .note-text {
            fill: white;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
        }
        
        .note-key {
            fill: white;
            stroke: black;
            stroke-width: 1px;
            text-anchor: middle;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
        }

        /* Note specific colors - SOLID OPAQUE COLORS */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]) { 
            fill: rgba(231, 76, 60, 1);
        }
        
        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]) { 
            fill: #f1c40f; 
        }
        
        .hexagon[data-note-name^="E"] { 
            fill: #2ecc71; 
        }
        
        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]) { 
            fill: #3498db; 
        }
        
        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]) { 
            fill: #9b59b6; 
        }
        
        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]) { 
            fill: #e67e22; 
        }
        
        .hexagon[data-note-name^="B"] { 
            fill: #1abc9c; 
        }
        
        .hexagon[data-note-name*="#"] { 
            fill: #34495e; 
        }

        /* Simple active state - just a brighter color */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]).active { 
            fill: #ff6b6b; 
        }
        
        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]).active { 
            fill: #f5d76e; 
        }
        
        .hexagon[data-note-name^="E"].active { 
            fill: #4cd964; 
        }
        
        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]).active { 
            fill: #5ac8fa; 
        }
        
        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]).active { 
            fill: #af7ac5; 
        }
        
        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]).active { 
            fill: #f39c12; 
        }
        
        .hexagon[data-note-name^="B"].active { 
            fill: #48c9b0; 
        }
        
        .hexagon[data-note-name*="#"].active { 
            fill: #5d6d7e; 
        }
        
        /* --- SVG Piano Styling --- */
        .piano-svg {
            display: block;
            transform: rotate(0deg);
            transition: transform 0.3s ease;
            width: 100%;
            height: 100%;
        }

        /* Rotate the hexboard in portrait mode */
        @media screen and (orientation: portrait) {
            .piano-svg {
                transform: rotate(90deg);
                max-width: 100vh;
                max-height: 100vw;
            }
        }

        /* Alternative approach using aspect ratio instead of orientation */
        @media screen and (max-aspect-ratio: 1/1) {
            .piano-svg {
                transform: rotate(90deg);
                max-width: 100vh;
                max-height: 100vw;
            }
        }

        /* Pulse animation for recording button */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 65, 54, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 65, 54, 0);
            }
        }
    </style>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', function() {
            var DEBUG = false;
        
            // --- DOM ELEMENTS ---
            var hexboard = document.querySelector('.hexboard');
            var recordButton = document.getElementById('record-button');
            var playButton = document.getElementById('play-button');
            var playIcon = document.getElementById('play-icon');
            var stopIcon = document.getElementById('stop-icon');
            var waveTypeSelect = document.getElementById('wave-type');
            var volumeSlider = document.getElementById('volume-slider');
            var fullscreenButton = document.getElementById('fullscreen-button');
            var fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            var fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');

            // --- AUDIO SETUP ---
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            var audioContext;
            var mainGainNode;
            var activeOscillators = {};
            var audioSupported = true;
            var audioInitialized = false;
            var firstUserInteraction = false;

            // --- STATE MANAGEMENT ---
            var isRecording = false;
            var isPlaying = false;
            var recordingStartTime;
            var recordedMelody = [
                { note: 'C4', freq: 261.63, time: 0, duration: 300 },
                { note: 'E4', freq: 329.63, time: 400, duration: 300 },
                { note: 'G4', freq: 392.00, time: 800, duration: 300 },
                { note: 'E4', freq: 329.63, time: 1200, duration: 300 },
                { note: 'C4', freq: 261.63, time: 1600, duration: 300 },
                { note: 'E4', freq: 329.63, time: 2000, duration: 300 },
                { note: 'G4', freq: 392.00, time: 2400, duration: 300 },
                { note: 'E4', freq: 329.63, time: 2800, duration: 300 },
                
                { note: 'C4', freq: 261.63, time: 3200, duration: 300 },
                { note: 'E4', freq: 329.63, time: 3200, duration: 300 },
                { note: 'G4', freq: 392.00, time: 3200, duration: 300 },
            ];
            var playbackTimeouts = [];
            var recordingActiveNotes = {};
            var notesByPointerId = {};
            var firstNoteTime = null;
            var isDragging = false;
            var currentMouseNote = null;

            // --- NOTE DATA (Wicki-Hayden inspired layout) ---
            var noteLayout = [
                // Octave 3
                { key: '', note: 'C3', freq: 130.81, type: 'white' },
                { key: '', note: 'C#3', freq: 138.59, type: 'black' },
                { key: '', note: 'D3', freq: 146.83, type: 'white' },
                { key: '', note: 'D#3', freq: 155.56, type: 'black' },
                { key: '', note: 'E3', freq: 164.81, type: 'white' },
                { key: '', note: 'F3', freq: 174.61, type: 'white' },
                { key: '', note: 'F#3', freq: 185.00, type: 'black' },
                { key: 'z', note: 'G3', freq: 196.00, type: 'white' },
                { key: 'x', note: 'G#3', freq: 207.65, type: 'black' },
                { key: 'c', note: 'A3', freq: 220.00, type: 'white' },
                { key: 'v', note: 'A#3', freq: 233.08, type: 'black' },
                { key: 'b', note: 'B3', freq: 246.94, type: 'white' },

                // Octave 4 (Middle C is C4)
                { key: 'a', note: 'C4', freq: 261.63, type: 'white' },
                { key: 'q', note: 'C#4', freq: 277.18, type: 'black' },
                { key: 's', note: 'D4', freq: 293.66, type: 'white' },
                { key: 'w', note: 'D#4', freq: 311.13, type: 'black' },
                { key: 'd', note: 'E4', freq: 329.63, type: 'white' },
                { key: 'f', note: 'F4', freq: 349.23, type: 'white' },
                { key: 'e', note: 'F#4', freq: 369.99, type: 'black' },
                { key: 'g', note: 'G4', freq: 392.00, type: 'white' },
                { key: 'r', note: 'G#4', freq: 415.30, type: 'black' },
                { key: 'h', note: 'A4', freq: 440.00, type: 'white' },
                { key: 't', note: 'A#4', freq: 466.16, type: 'black' },
                { key: 'j', note: 'B4', freq: 493.88, type: 'white' },

                // Octave 5
                { key: 'k', note: 'C5', freq: 523.25, type: 'white' },
                { key: 'o', note: 'C#5', freq: 554.37, type: 'black' },
                { key: 'l', note: 'D5', freq: 587.33, type: 'white' },
                { key: 'p', note: 'D#5', freq: 622.25, type: 'black' },
                { key: '1', note: 'E5', freq: 659.25, type: 'white' },
                { key: '2', note: 'F5', freq: 698.46, type: 'white' },
                { key: '3', note: 'F#5', freq: 739.99, type: 'black' },
                { key: '4', note: 'G5', freq: 783.99, type: 'white' },
                { key: '5', note: 'G#5', freq: 830.61, type: 'black' },
                { key: '6', note: 'A5', freq: 880.00, type: 'white' },
                { key: '7', note: 'A#5', freq: 932.33, type: 'black' },
                { key: '8', note: 'B5', freq: 987.77, type: 'black' },

                // Octave 6
                { key: '9', note: 'C6', freq: 1046.50, type: 'white' },
                { key: '0', note: 'C#6', freq: 1108.73, type: 'black' },
                { key: '', note: 'D6', freq: 1174.66, type: 'white' },
                { key: '', note: 'D#6', freq: 1244.51, type: 'black' },
                { key: '', note: 'E6', freq: 1318.51, type: 'white' },
                { key: '', note: 'F6', freq: 1396.91, type: 'white' },
                { key: '', note: 'F#6', freq: 1479.98, type: 'black' },
                { key: '', note: 'G6', freq: 1567.98, type: 'white' },
                { key: '', note: 'G#6', freq: 1661.22, type: 'black' },
                { key: '', note: 'A6', freq: 1760.00, type: 'white' },
                { key: '', note: 'A#6', freq: 1864.66, type: 'black' },
                { key: '', note: 'B6', freq: 1975.53, type: 'white' },

                // Octave 7
                { key: '', note: 'C7', freq: 2093.00, type: 'white' },
                { key: '', note: 'C#7', freq: 2217.46, type: 'black' },
                { key: '', note: 'D7', freq: 2349.32, type: 'white' },
                { key: '', note: 'D#7', freq: 2489.02, type: 'black' },
                { key: '', note: 'E7', freq: 2637.02, type: 'white' },
                { key: '', note: 'F7', freq: 2793.83, type: 'white' },
                { key: '', note: 'F#7', freq: 2959.96, type: 'black' },
                { key: '', note: 'G7', freq: 3135.96, type: 'white' },
                { key: '', note: 'G#7', freq: 3322.44, type: 'black' },
                { key: '', note: 'A7', freq: 3520.00, type: 'white' },
                { key: '', note: 'A#7', freq: 3729.31, type: 'black' },
                { key: '', note: 'B7', freq: 3951.07, type: 'white' }
            ];
                    
            var noteRows = [
                noteLayout.slice(0, 12),   // C3 to B3
                noteLayout.slice(12, 24),  // C4 to B4
                noteLayout.slice(24, 36),  // C5 to B5
                noteLayout.slice(36, 48),  // C6 to B6
                noteLayout.slice(48, 60),  // C7 to B7
            ];

            var notesByKey = {};
            var notesByNoteName = {};

            // --- INITIALIZATION ---
            function init() {
                createPiano();
                addEventListeners();
                
                // Try to initialize audio context on page load
                tryInitAudioContext();
                
                // Add a one-time event listener for any user interaction
                function handleFirstInteraction() {
                    if (!firstUserInteraction) {
                        firstUserInteraction = true;
                        if (!audioInitialized) {
                            initAudioContext();
                        }
                        // Remove this listener after first interaction
                        document.removeEventListener('click', handleFirstInteraction);
                        document.removeEventListener('keydown', handleFirstInteraction);
                        document.removeEventListener('touchstart', handleFirstInteraction);
                    }
                }
                
                document.addEventListener('click', handleFirstInteraction);
                document.addEventListener('keydown', handleFirstInteraction);
                document.addEventListener('touchstart', handleFirstInteraction);
            }

            function tryInitAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                try {
                    // Try to create audio context
                    audioContext = new AudioContext();
                    
                    // If it's not suspended, we can fully initialize
                    if (audioContext.state !== 'suspended') {
                        completeAudioContextInit();
                    } else {
                        // If suspended, we'll wait for user interaction
                        if(DEBUG) {
                            console.log("Audio context created but suspended, waiting for user interaction");
                        }
                    }
                } catch (e) {
                    console.error("Error creating audio context:", e);
                    audioSupported = false;
                }
            }

            function initAudioContext() {
                if (!AudioContext) {
                    console.error("Web Audio API is not supported in this browser");
                    audioSupported = false;
                    return;
                }
                
                if (audioInitialized) {
                    if(DEBUG) {
                        console.log("Audio context already initialized");
                    }
                    return;
                }
                
                try {
                    // Create or get existing audio context
                    if (!audioContext) {
                        audioContext = new AudioContext();
                    }
                    
                    completeAudioContextInit();
                    
                    // Resume the context if it's suspended
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed successfully");
                                console.log("Audio context state after resume:", audioContext.state);
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context:", e);
                        });
                    }
                } catch (e) {
                    console.error("Error initializing audio context:", e);
                    audioSupported = false;
                }
            }
            
            function completeAudioContextInit() {
                mainGainNode = audioContext.createGain();
                mainGainNode.gain.value = volumeSlider.value;
                mainGainNode.connect(audioContext.destination);
                audioInitialized = true;
                
                if(DEBUG) {
                    console.log("Audio context initialized successfully");
                    console.log("Audio context state:", audioContext.state);
                }
                
                // Handle state changes
                audioContext.addEventListener('statechange', function() {
                    if(DEBUG) {
                        console.log("Audio context state changed to:", audioContext.state);
                    }
                    
                    // If the context is suspended, try to resume it
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(function() {
                            if(DEBUG) {
                                console.log("Audio context resumed after state change");
                            }
                        }).catch(function(e) {
                            console.error("Error resuming audio context after state change:", e);
                        });
                    }
                });
            }
            
            function ensureAudioContextResumed() {
                if (!audioContext || !audioInitialized) {
                    console.error("Audio context is not initialized");
                    return false;
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(function() {
                        if(DEBUG) {
                            console.log("Audio context resumed successfully");
                        }
                    }).catch(function(e) {
                        console.error("Error resuming audio context:", e);
                    });
                    return false;
                }
                
                return true;
            }

            function createPiano() {
                // Create main SVG container
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'piano-svg');
                
                // Hexagon dimensions for proper tiling (flat left and right sides)
                var hexRadius = 50; // Radius from center to any vertex
                var hexWidth = hexRadius * 2; // Width of hexagon (flat to flat)
                var hexHeight = Math.sqrt(3) * hexRadius; // Height of hexagon (point to point)
                
                var horizontalSpacing = hexWidth - 15;
                var verticalSpacing = hexHeight - 15;
                
                // Calculate total width and height with proper spacing
                var maxRowLength = Math.max(...noteRows.map(row => row.length));
                
                // For width: (maxRowLength-1) * spacing + hexWidth + offset for odd rows
                // The offset accounts for the half-spacing shift in alternating rows
                var totalWidth = (maxRowLength - 1) * horizontalSpacing + hexWidth + (horizontalSpacing / 2);
                
                // For height: (noteRows.length-1) * spacing + hexHeight
                // This properly accounts for the spacing between rows
                var totalHeight = (noteRows.length - 1) * verticalSpacing + hexHeight;
                
                // Set SVG dimensions
                svg.setAttribute('width', "100%");
                svg.setAttribute('height', "100%");
                svg.setAttribute('viewBox', '0 0 ' + totalWidth + ' ' + totalHeight);
                
                // Create hexagon points (flat left and right sides - pointy top)
                function getHexagonPoints(cx, cy, radius) {
                    var points = [];
                    // Start at top point and go clockwise
                    for (var i = 0; i < 6; i++) {
                        // 30°, 90°, 150°, 210°, 270°, 330° for flat left/right
                        var angle = (Math.PI / 3) * i - Math.PI / 2;
                        var x = cx + radius * Math.cos(angle);
                        var y = cy + radius * Math.sin(angle);
                        points.push(x + ',' + y);
                    }
                    return points.join(' ');
                }
                
                // Create hexagons for each note
                for (var i = 0; i < noteRows.length; i++) {
                    var rowData = noteRows[i];
                    
                    // Calculate row offset for hexagonal tiling
                    var rowOffsetX = (i % 2 === 1) ? horizontalSpacing / 2 : 0;
                    var rowOffsetY = i * verticalSpacing;
                    
                    for (var j = 0; j < rowData.length; j++) {
                        var noteData = rowData[j];
                        
                        // Calculate center position for this hexagon
                        var cx = rowOffsetX + j * horizontalSpacing + hexRadius;
                        var cy = rowOffsetY + hexRadius;
                        
                        // Create group for hexagon and text
                        var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'hexagon-group');
                        
                        // Create hexagon polygon
                        var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('class', 'hexagon');
                        polygon.setAttribute('id', noteData.note);
                        polygon.setAttribute('points', getHexagonPoints(cx, cy, hexRadius));
                        polygon.setAttribute('data-key', noteData.key);
                        polygon.setAttribute('data-note', noteData.note);
                        polygon.setAttribute('data-freq', noteData.freq);
                        polygon.setAttribute('data-note-name', noteData.note.replace(/[0-9]/, ''));
                        
                        // Create note name text
                        var noteText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        noteText.setAttribute('class', 'note-text');
                        noteText.setAttribute('x', cx);
                        noteText.setAttribute('y', cy - 5);
                        noteText.textContent = noteData.note;
                        
                        // Create key label text
                        var keyText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        keyText.setAttribute('class', 'note-key');
                        keyText.setAttribute('x', cx);
                        keyText.setAttribute('y', cy + 15);
                        keyText.textContent = noteData.key === 'Shift' ? '⇧' : noteData.key.toUpperCase();
                        
                        // Add elements to group
                        g.appendChild(polygon);
                        g.appendChild(noteText);
                        g.appendChild(keyText);
                        
                        // Add group to SVG
                        svg.appendChild(g);
                        
                        // Store references for event handling
                        notesByKey[noteData.key.toLowerCase()] = noteData;
                        notesByNoteName[noteData.note] = notesByNoteName[noteData.note] || [];
                        notesByNoteName[noteData.note].push(polygon);
                    }
                }
                
                // Add SVG to hexboard
                hexboard.appendChild(svg);
            }
            
            // --- AUDIO PLAYBACK ---
            function playNote(note, freq) {
                if (!audioSupported) {
                    console.warn("Audio is not supported in this browser");
                    return;
                }
                
                // Initialize audio context if not already done
                if (!audioInitialized) {
                    initAudioContext();
                }
                
                if (!audioContext || !audioInitialized) {
                    console.error("Audio context is not initialized");
                    return;
                }
                
                if (!ensureAudioContextResumed()) {
                    console.error("Audio context could not be resumed");
                    return;
                }
                
                // If note is already playing, stop it first
                if (activeOscillators[note]) {
                    stopNote(note);
                }

                try {
                    var now = audioContext.currentTime;
                    var gainValue = 0.7;

                    // Check if createOscillator is available
                    if (typeof audioContext.createOscillator !== 'function') {
                        throw new Error("createOscillator is not a function on audio context");
                    }

                    var oscillator = audioContext.createOscillator();
                    var gainNode = audioContext.createGain();

                    oscillator.type = waveTypeSelect.value;
                    oscillator.frequency.setValueAtTime(freq, now);
                    
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(gainValue, now + 0.02);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(mainGainNode);
                    oscillator.start(now);

                    activeOscillators[note] = { 
                        oscillator: oscillator, 
                        gainNode: gainNode
                    };
                    
                    if(DEBUG) {
                        console.log("Note started:", note, "Frequency:", freq);
                    }
                } catch (e) {
                    console.error("Error playing note:", e);
                }
            }
            
            function stopNote(note) {
                if (!audioSupported || !audioContext || !audioInitialized) return;
                
                if (!activeOscillators[note]) {
                    if(DEBUG) {
                        console.log("Note is not playing:", note);
                    }
                    return;
                }
                
                var oscillatorData = activeOscillators[note];
                
                try {
                    var oscillator = oscillatorData.oscillator;
                    var gainNode = oscillatorData.gainNode;
                    var now = audioContext.currentTime;
                    var releaseTime = 0.1; // Shorter release time for immediate stop
                    
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

                    oscillator.stop(now + releaseTime + 0.01);
                    
                    // Immediately remove from active oscillators
                    delete activeOscillators[note];
                    
                    if(DEBUG) {
                        console.log("Note stopped:", note);
                    }
                } catch (e) {
                    console.error("Error stopping note:", e);
                    // Still remove from active oscillators even if stopping failed
                    delete activeOscillators[note];
                }
            }

            // --- VISUAL FEEDBACK ---
            function showKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.add('active');
                    }
                }
            }

            function hideKeyPress(note) {
                var hexes = notesByNoteName[note];
                if (hexes) {
                    for (var i = 0; i < hexes.length; i++) {
                        hexes[i].classList.remove('active');
                    }
                }
            }

            // --- EVENT HANDLERS ---
            function handleNoteOn(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;
                var freq = noteData.freq;
                
                playNote(note, freq);
                showKeyPress(note);
                if (pointerId !== undefined) notesByPointerId[pointerId] = noteData;

                if (isRecording) {
                    var currentTime = performance.now();
                    
                    if (firstNoteTime === null) {
                        firstNoteTime = currentTime;
                    }
                    
                    recordingActiveNotes[note] = {
                        freq: freq,
                        startTime: currentTime
                    };
                }
            }

            function handleNoteOff(noteData, pointerId) {
                if (!noteData) return;
                var note = noteData.note;

                stopNote(note);
                hideKeyPress(note);
                if (pointerId !== undefined) delete notesByPointerId[pointerId];

                if (isRecording && recordingActiveNotes[note]) {
                    var noteStartData = recordingActiveNotes[note];
                    var noteEndTime = performance.now();
                    var durationMs = noteEndTime - noteStartData.startTime;

                    if (durationMs > 20) {
                        recordedMelody.push({
                            note: note,
                            freq: noteStartData.freq,
                            time: noteStartData.startTime - firstNoteTime,
                            duration: durationMs
                        });
                    }
                    delete recordingActiveNotes[note];
                }
            }

            function addEventListeners() {
                // Mouse events for SVG
                hexboard.addEventListener('mousedown', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        currentMouseNote = noteData;
                        handleNoteOn(noteData);
                    }
                });

                document.addEventListener('mousemove', function(e) {
                    if (!isDragging) return;
                    
                    var hex = document.elementFromPoint(e.clientX, e.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        
                        if (!currentMouseNote || currentMouseNote.note !== noteData.note) {
                            if (currentMouseNote) {
                                handleNoteOff(currentMouseNote);
                            }
                            handleNoteOn(noteData);
                            currentMouseNote = noteData;
                        }
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    if (currentMouseNote) {
                        handleNoteOff(currentMouseNote);
                        currentMouseNote = null;
                    }
                    
                    // Stop ALL notes when mouse is released
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                // Touch events for mobile
                hexboard.addEventListener('touchstart', function(e) {
                    var hex = e.target;
                    if (hex.classList.contains('hexagon')) {
                        e.preventDefault();
                        isDragging = true;
                        var touch = e.touches[0];
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        handleNoteOn(noteData, touch.identifier);
                    }
                });

                document.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    
                    var touch = e.touches[0];
                    var hex = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (hex && hex.classList.contains('hexagon')) {
                        var noteData = { 
                            note: hex.getAttribute('data-note'), 
                            freq: parseFloat(hex.getAttribute('data-freq')) 
                        };
                        var currentNoteData = notesByPointerId[touch.identifier];
                        
                        if (!currentNoteData || currentNoteData.note !== noteData.note) {
                            if (currentNoteData) {
                                handleNoteOff(currentNoteData, touch.identifier);
                            }
                            handleNoteOn(noteData, touch.identifier);
                        }
                    }
                });

                document.addEventListener('touchend', function(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    for (var i = 0; i < e.changedTouches.length; i++) {
                        var touch = e.changedTouches[i];
                        var noteData = notesByPointerId[touch.identifier];
                        if (noteData) {
                            handleNoteOff(noteData, touch.identifier);
                        }
                    }
                    
                    // Stop ALL notes when touch ends
                    for (var note in activeOscillators) {
                        stopNote(note);
                        hideKeyPress(note);
                    }
                });

                window.addEventListener('keydown', function(e) {
                    if (e.repeat || e.metaKey || e.ctrlKey) return;
                    var key = e.key.toLowerCase();
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOn(noteData);
                    }
                });
                
                window.addEventListener('keyup', function(e) {
                    var key = e.key.toLowerCase();
                    var noteData = notesByKey[key];
                    if (noteData) {
                        e.preventDefault();
                        handleNoteOff(noteData);
                    }
                });

                recordButton.addEventListener('click', toggleRecording);
                playButton.addEventListener('click', togglePlayback);
                fullscreenButton.addEventListener('click', toggleFullscreen);
                volumeSlider.addEventListener('input', function(e) {
                    if (mainGainNode) mainGainNode.gain.value = e.target.value;
                });
            }

            // --- CONTROL BAR LOGIC ---
            function toggleRecording() {
                if (!audioSupported) {
                    alert("Audio recording is not supported in this browser");
                    return;
                }
                
                isRecording = !isRecording;
                if (isRecording) {
                    if (isPlaying) stopPlayback();
                    recordButton.className = 'recording';
                    recordedMelody = [];
                    recordingActiveNotes = {};
                    recordingStartTime = performance.now();
                    firstNoteTime = null;
                } else {
                    recordButton.className = '';
                    var recordingStopTime = performance.now();
                    
                    for (var note in recordingActiveNotes) {
                        if (recordingActiveNotes.hasOwnProperty(note)) {
                            var noteStartData = recordingActiveNotes[note];
                            recordedMelody.push({
                                note: note,
                                freq: noteStartData.freq,
                                time: noteStartData.startTime - firstNoteTime,
                                duration: recordingStopTime - noteStartData.startTime
                            });
                        }
                    }
                    recordingActiveNotes = {};

                    if (recordedMelody.length > 0) {
                        generateWav();
                    }
                }
            }
            
            function togglePlayback() {
                if (!audioSupported) {
                    alert("Audio playback is not supported in this browser");
                    return;
                }
                
                if (isPlaying) stopPlayback();
                else if (recordedMelody.length > 0) startPlayback();
            }
            
            function startPlayback() {
                if (isRecording) toggleRecording();
        
                isPlaying = true;
                playIcon.style.display = 'none';
                stopIcon.style.display = 'block';
                
                console.log(recordedMelody);

                // Ensure audio context is resumed before starting playback
                if (!ensureAudioContextResumed()) {
                    console.error("Cannot start playback: audio context could not be resumed");
                    stopPlayback();
                    return;
                }

                for (var i = 0; i < recordedMelody.length; i++) {
                    var noteEvent = recordedMelody[i];
                    var noteData = { note: noteEvent.note, freq: noteEvent.freq };
                    
                    (function(note, time, duration) {
                        var playTimeout = setTimeout(function() { 
                            // Double-check audio context before playing each note
                            if (ensureAudioContextResumed()) {
                                handleNoteOn(note); 
                            } else {
                                console.error("Cannot play note: audio context could not be resumed");
                            }
                        }, time);
                        var stopTimeout = setTimeout(function() { 
                            handleNoteOff(note); 
                        }, time + duration);
                        playbackTimeouts.push(playTimeout, stopTimeout);
                    })(noteData, noteEvent.time, noteEvent.duration);
                }
                
                var totalDuration = recordedMelody.length > 0 ? 
                    Math.max.apply(Math, recordedMelody.map(function(n) { return n.time + n.duration; })) : 0;
                var finalTimeout = setTimeout(stopPlayback, totalDuration + 500);
                playbackTimeouts.push(finalTimeout);
            }

            function stopPlayback() {
                isPlaying = false;
                playIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                
                for (var i = 0; i < playbackTimeouts.length; i++) {
                    clearTimeout(playbackTimeouts[i]);
                }
                playbackTimeouts = [];
                
                // Stop all notes when playback stops
                for (var note in activeOscillators) {
                    stopNote(note);
                    hideKeyPress(note);
                }
            }
            
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    } else if (document.documentElement.webkitRequestFullscreen) {
                        document.documentElement.webkitRequestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) {
                        document.documentElement.mozRequestFullScreen();
                    } else if (document.documentElement.msRequestFullscreen) {
                        document.documentElement.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            }
            
            document.addEventListener('fullscreenchange', function() {
                var isFullscreen = !!document.fullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('webkitfullscreenchange', function() {
                var isFullscreen = !!document.webkitFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('mozfullscreenchange', function() {
                var isFullscreen = !!document.mozFullScreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            document.addEventListener('MSFullscreenChange', function() {
                var isFullscreen = !!document.msFullscreenElement;
                fullscreenEnterIcon.style.display = isFullscreen ? 'none' : 'block';
                fullscreenExitIcon.style.display = isFullscreen ? 'block' : 'none';
            });
            
            // --- WAV EXPORT ---
            function generateWav() {
                if (recordedMelody.length === 0 || !audioSupported) return;

                var totalMs = Math.max.apply(Math, recordedMelody.map(function(note) { 
                    return note.time + note.duration; 
                }));
                var durationSec = (totalMs / 1000) + 0.5;
                
                try {
                    var offlineContext = new OfflineAudioContext(1, Math.ceil(44100 * durationSec), 44100);
                    var offlineGainNode = offlineContext.createGain();
                    offlineGainNode.gain.value = volumeSlider.value;
                    offlineGainNode.connect(offlineContext.destination);

                    for (var i = 0; i < recordedMelody.length; i++) {
                        var note = recordedMelody[i];
                        var startTime = note.time / 1000;
                        var noteDuration = note.duration / 1000;
                        if (noteDuration <= 0.01) continue;

                        var attackTime = 0.02;
                        var releaseTime = Math.min(noteDuration * 0.5, 0.2);

                        var oscillator = offlineContext.createOscillator();
                        var gainNode = offlineContext.createGain();
                        
                        oscillator.type = waveTypeSelect.value;
                        oscillator.frequency.value = note.freq;

                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.7, startTime + attackTime);
                        gainNode.gain.linearRampToValueAtTime(0, startTime + noteDuration);

                        oscillator.connect(gainNode);
                        gainNode.connect(offlineGainNode);
                        oscillator.start(startTime);
                        oscillator.stop(startTime + noteDuration + 0.05);
                    }

                    offlineContext.startRendering().then(function(renderedBuffer) {
                        var wavBlob = bufferToWave(renderedBuffer);
                        downloadBlob(wavBlob, 'hexagon-melody.wav');
                    }).catch(function(e) {
                        console.error("Failed to render WAV:", e);
                        alert("Sorry, there was an error creating the audio file.");
                    });
                } catch (e) {
                    console.error("Error generating WAV:", e);
                    alert("Sorry, there was an error creating the audio file.");
                }
            }

            function downloadBlob(blob, filename) {
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(url);
                a.parentNode.removeChild(a);
            }

            function bufferToWave(abuffer) {
                var numOfChan = abuffer.numberOfChannels,
                    len = abuffer.length * numOfChan * 2 + 44,
                    buffer = new ArrayBuffer(len),
                    view = new DataView(buffer),
                    channels = [],
                    i, sample, offset = 0, pos = 0;
                
                // Write WAVE header
                setUint32(0x46464952); // "RIFF"
                setUint32(len - 8); // file length - 8
                setUint32(0x45564157); // "WAVE"
                setUint32(0x20746d66); // "fmt " chunk
                setUint32(16); // length = 16
                setUint16(1); // PCM
                setUint16(numOfChan);
                setUint32(abuffer.sampleRate);
                setUint32(abuffer.sampleRate * 4); // avg. bytes/sec
                setUint16(4); // block-align
                setUint16(16); // 16-bit
                
                // Write data chunk
                setUint32(0x61746164); // "data" - chunk
                setUint32(len - pos - 4); // chunk length
                
                // Write interleaved data
                for (i = 0; i < abuffer.numberOfChannels; i++)
                    channels.push(abuffer.getChannelData(i));
                
                while (pos < len - 44) {
                    for (i = 0; i < numOfChan; i++) {
                        sample = Math.max(-1, Math.min(1, channels[i][offset]));
                        sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(pos, sample, true);
                        pos += 2;
                    }
                    offset++;
                }
                
                return new Blob([buffer], { type: "audio/wav" });
                
                function setUint16(data) {
                    view.setUint16(pos, data, true);
                    pos += 2;
                }
                
                function setUint32(data) {
                    view.setUint32(pos, data, true);
                    pos += 4;
                }
            }

            init();
        });
    </script>
</head>
<body>
    <div class="app-container">
        <div class="control-bar">
            <button id="record-button" title="Record / Stop and Save WAV">
                <div id="record-indicator"></div>
            </button>
            <button id="play-button" title="Play / Stop Melody">
                <svg id="play-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="stop-icon" class="icon" viewBox="0 0 24 24" style="display: none;">
                    <path d="M6 6h12v12H6z"/>
                </svg>
            </button>

            <span class="control-bar-label">Wave</span>
            <select id="wave-type">
                <option value="sine" selected>Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            </select>

            <span class="control-bar-label">Volume</span>
            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01">

            <div style="display: inline-block; width: 50px;"></div> <!-- Spacer -->

            <button id="fullscreen-button" title="Toggle Fullscreen">
                <svg id="fullscreen-enter-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
                <svg id="fullscreen-exit-icon" class="icon" viewBox="0 0 24 24" style="display:none;">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                </svg>
            </button>
        </div>
        <div class="hexboard">
            <!-- SVG piano will be generated here -->
        </div>
    </div>
</body>
</html>
